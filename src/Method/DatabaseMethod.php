<?php

namespace Phabalicious\Method;

use Phabalicious\Configuration\ConfigurationService;
use Phabalicious\Configuration\HostConfig;
use Phabalicious\Configuration\Storage\Node;
use Phabalicious\Exception\FailedShellCommandException;
use Phabalicious\Exception\MethodNotFoundException;
use Phabalicious\Exception\TaskNotFoundInMethodException;
use Phabalicious\Exception\ValidationFailedException;
use Phabalicious\ShellProvider\CommandResult;
use Phabalicious\ShellProvider\ShellProviderInterface;
use Phabalicious\Validation\ValidationErrorBag;
use Phabalicious\Validation\ValidationErrorBagInterface;
use Phabalicious\Validation\ValidationService;

abstract class DatabaseMethod extends BaseMethod implements DatabaseMethodInterface
{
    public const DATABASE_CREDENTIALS = 'databaseCredentials';
    public const DROP_DATABASE = 'dropDatabase';

    public const SQL_QUERY = 'db:query';

    public function getDefaultConfig(ConfigurationService $configuration_service, Node $host_config): Node
    {
        $parent = parent::getDefaultConfig($configuration_service, $host_config);

        $config = [];

        if (isset($host_config['database'])) {
            $config['database']['skipCreateDatabase'] = false;
            $config['database']['prefix'] = false;
            $config['database']['driver'] = $this->getName();
        }

        $config['supportsZippedBackups'] = true;

        return $parent->merge(new Node($config, $this->getName().' method defaults'));
    }

    public function isRunningAppRequired(HostConfig $host_config, TaskContextInterface $context, string $task): bool
    {
        return parent::isRunningAppRequired($host_config, $context, $task)
            || in_array($task, [
                'database',
                'backup',
                'restore',
                'install',
                'listBackups',
                'restoreSqlFromFilePreparation',
                'restoreSqlFromFile',
                'getSQLDump',
                'copyFrom',
                'copyFromPrepareSource',
                'requestDatabaseCredentialsAndWorkingDir',
            ]);
    }

    public function validateConfig(
        ConfigurationService $configuration_service,
        Node $config,
        ValidationErrorBagInterface $errors,
    ) {
        parent::validateConfig($configuration_service, $config, $errors);
        // TODO: Change the autogenerated stub

        $service = new ValidationService($config, $errors, sprintf('host: `%s`', $config['configName']));

        $service->hasKey('backupFolder', $this->getName().' needs to know where to store backups into');

        if (!empty($config['database'])) {
            $this->validateCredentials($config['database'], $errors);
        }
    }

    public function backup(HostConfig $host_config, TaskContextInterface $context)
    {
        $shell = $this->getShell($host_config, $context);
        $what = $context->get('what', []);
        if (!in_array('db', $what)) {
            return;
        }

        $basename = $context->getResult('basename');
        $backup_file_name = $host_config['backupFolder'].'/'.implode('--', $basename).'.sql';

        $backup_file_name = $this->exportSqlToFile($host_config, $context, $shell, $backup_file_name);

        $context->addResult('files', [[
            'type' => 'db',
            'file' => $backup_file_name,
        ]]);

        $this->logger->notice('Database dumped to `'.$backup_file_name.'`');
    }

    public function getSQLDump(HostConfig $host_config, TaskContextInterface $context)
    {
        $filename = $host_config['tmpFolder'].'/'
            .$host_config->getConfigName().'.'
            .date('Y-m-d-H-m-s')
            .'.sql';
        $shell = $this->getShell($host_config, $context);
        $filename = $this->exportSqlToFile($host_config, $context, $shell, $filename);

        $context->addResult('files', [$filename]);
    }

    public function listBackups(HostConfig $host_config, TaskContextInterface $context)
    {
        $shell = $this->getShell($host_config, $context);
        $files = $this->getRemoteFiles($shell, $host_config['backupFolder'], ['*.sql.gz', '*.sql']);
        $result = [];
        foreach ($files as $file) {
            $tokens = $this->parseBackupFile($host_config, $file, 'db');
            if ($tokens) {
                $result[] = $tokens;
            }
        }

        $existing = $context->getResult('files', []);
        $context->setResult('files', array_merge($existing, $result));
    }

    /**
     * @throws FailedShellCommandException
     */
    public function restore(HostConfig $host_config, TaskContextInterface $context)
    {
        $shell = $this->getShell($host_config, $context);
        $what = $context->get('what', []);
        if (!in_array('db', $what)) {
            return;
        }

        $backup_set = $context->get('backup_set', []);
        foreach ($backup_set as $elem) {
            if ('db' != $elem['type']) {
                continue;
            }

            $result = $this->importSqlFromFile(
                $host_config,
                $context,
                $shell,
                $host_config['backupFolder'].'/'.$elem['file'],
                true
            );

            if (!$result->succeeded()) {
                $result->throwException('Could not restore backup from '.$elem['file']);
            }
            $context->addResult('files', [[
                'type' => 'db',
                'file' => $elem['file'],
            ]]);
        }
    }

    public function restoreSqlFromFile(HostConfig $host_config, TaskContextInterface $context)
    {
        $file = $context->get('source', false);
        if (!$file) {
            throw new \InvalidArgumentException('Missing file parameter');
        }

        // Make sure, there is a db to copy into.
        $this->waitForDatabase($host_config, $context);
        $this->install($host_config, $context);

        $shell = $this->getShell($host_config, $context);

        $result = $this->importSqlFromFile(
            $host_config,
            $context,
            $shell,
            $file,
            $context->get(self::DROP_DATABASE, true)
        );

        $context->setResult('exitCode', $result->getExitCode());
    }

    public function copyFromPrepareSource(HostConfig $host_config, TaskContextInterface $context)
    {
        $what = $context->get('what');
        if (!in_array('db', $what)) {
            return;
        }

        // Make sure, there is a db to copy from.
        $this->waitForDatabase($host_config, $context);
    }

    /**
     * @throws FailedShellCommandException
     */
    public function copyFrom(HostConfig $host_config, TaskContextInterface $context)
    {
        $what = $context->get('what');
        if (!in_array('db', $what)) {
            return;
        }
        // Make sure, there is a db to copy into.
        $this->waitForDatabase($host_config, $context);
        $this->install($host_config, $context);

        $from_config = $context->get('from', false);
        /** @var HostConfig $from_config */
        $shell = $this->getShell($host_config, $context);
        /** @var ShellProviderInterface $shell */
        $from_shell = $context->get('fromShell', $from_config->shell());
        /** @var ShellProviderInterface $from_shell */
        $from_filename = $from_config['tmpFolder'].'/'.$from_config->getConfigName()
            .'.'.date('YmdHms').'.sql';
        $from_filename = $this->exportSqlToFile($from_config, $context, $from_shell, $from_filename);

        $to_filename = $host_config['tmpFolder'].'/to--'.basename($from_filename);

        // Copy filename to host
        $context->io()->comment(sprintf(
            'Copying dump from `%s` to `%s` ...',
            $from_config->getConfigName(),
            $host_config->getConfigName()
        ));

        $result = $shell->copyFileFrom($from_shell, $from_filename, $to_filename, $context, true);
        if (!$result) {
            throw new \RuntimeException(sprintf('Could not copy file from `%s` to `%s`', $from_filename, $to_filename));
        }
        $from_shell->run(sprintf(' rm %s', $from_filename));

        // Import db.
        $context->io()->comment(sprintf(
            'Importing dump into `%s` ...',
            $host_config->getConfigName()
        ));

        $result = $this->importSqlFromFile(
            $host_config,
            $context,
            $shell,
            $to_filename,
            $context->get(self::DROP_DATABASE, true)
        );
        if (!$result->succeeded()) {
            $result->throwException('Could not import DB from file `'.$to_filename.'`');
        }

        $shell->run(sprintf('rm %s', $to_filename));

        $context->io()->success('Copied the database successfully!');
    }

    public function appCreate(HostConfig $host_config, TaskContextInterface $context)
    {
        if (!$current_stage = $context->get('currentStage', false)) {
            throw new \InvalidArgumentException('Missing currentStage on context!');
        }
        if ('install' === $current_stage) {
            $this->waitForDatabase($host_config, $context);
            $this->install($host_config, $context);
        }
    }

    public function collectBackupMethods(HostConfig $config, TaskContextInterface $context)
    {
        $context->addResult('backupMethods', ['db']);
    }

    /**
     * @throws MethodNotFoundException
     * @throws TaskNotFoundInMethodException
     * @throws ValidationFailedException
     */
    protected function requestCredentialsAndWorkingDir(
        HostConfig $host_config,
        TaskContextInterface $context,
        array $credentials,
    ) {
        $cloned_context = clone $context;
        $cloned_context->set(self::DATABASE_CREDENTIALS, $credentials);
        $context->getConfigurationService()->getMethodFactory()->runTask(
            'requestDatabaseCredentialsAndWorkingDir',
            $host_config,
            $cloned_context
        );
        $data = $cloned_context->getResult(self::DATABASE_CREDENTIALS, $credentials);
        $errors = new ValidationErrorBag();
        $this->validateCredentials($data, $errors, true);
        if ($errors->hasErrors()) {
            throw new ValidationFailedException($errors);
        }

        return $data;
    }

    public function waitForDatabase(HostConfig $host_config, TaskContextInterface $context): bool
    {
        $shell = $this->getShell($host_config, $context);
        $tries = 0;
        $result = false;
        while ($tries < 10) {
            $result = $this->checkDatabaseConnection($host_config, $context, $shell);
            if ($result->succeeded()) {
                return true;
            }
            $this->logger->info('Wait another 5 secs for database ...');

            sleep(5);
            ++$tries;
        }
        if ($result) {
            $result->throwException('Could not connect to database!');
        }

        return false;
    }

    /**
     * @throws MethodNotFoundException
     * @throws TaskNotFoundInMethodException
     * @throws ValidationFailedException
     */
    protected function getDatabaseCredentials(HostConfig $host_config, TaskContextInterface $context): array
    {
        static $cache = [];
        $key = $host_config->getConfigName();
        if (isset($cache[$key])) {
            return $cache[$key];
        }
        $data = !empty($host_config['database']) ? $host_config['database'] : [];
        $cache[$key] = $this->requestCredentialsAndWorkingDir($host_config, $context, $data);

        return $cache[$key];
    }

    /**
     * @throws TaskNotFoundInMethodException
     * @throws MethodNotFoundException
     * @throws ValidationFailedException
     */
    public function database(HostConfig $host_config, TaskContextInterface $context)
    {
        $what = $context->get('what');
        $data = $this->getDatabaseCredentials($host_config, $context);
        $shell = $this->getShell($host_config, $context);

        switch ($what) {
            case 'install':
                $this->waitForDatabase($host_config, $context);

                return $this->install($host_config, $context);
                break;

            case 'drop':
                return $this->dropDatabase($host_config, $context, $shell, $data);
                break;

            case 'query':
                $result = $this->runQuery($host_config, $context, $shell, $data);
                $context->setCommandResult($result);

                return $result;
                break;

            case 'shell':
            case 'shell-command':
                $command = $this->getShellCommand($host_config, $context);
                foreach ($command as $ndx => $cmd) {
                    $command[$ndx] = $shell->expandCommand($cmd);
                }
                $command = $context->getPasswordManager()->resolveSecrets($command);
                $context->setResult('shell-command', $command);

                return true;
        }
        throw new \RuntimeException(sprintf('Unknown database command `%s`', $what));
    }

    public function runQuery(
        HostConfig $host_config,
        TaskContextInterface $context,
        ShellProviderInterface $shell,
        array $data,
    ): CommandResult {
        throw new \RuntimeException('Method runQuery not implemented!');
    }
}
