<?php

namespace Phabalicious\Method;

use Phabalicious\Configuration\HostConfig;
use Phabalicious\Exception\MethodNotFoundException;
use Phabalicious\Exception\MissingScriptCallbackImplementation;
use Phabalicious\Exception\TaskNotFoundInMethodException;
use Phabalicious\ShellProvider\ShellProviderInterface;
use Phabalicious\Utilities\AppDefaultStages;
use Phabalicious\Validation\ValidationErrorBagInterface;
use Phabalicious\Validation\ValidationService;

abstract class ArtifactsBaseMethod extends BaseMethod
{
    const PREFS_KEY = 'artifact';

    public function validateConfig(array $config, ValidationErrorBagInterface $errors)
    {
        parent::validateConfig($config, $errors); // TODO: Change the autogenerated stub

        $service = new ValidationService($config, $errors, 'Host-config '. $config['configName']);
        $service->isArray(self::PREFS_KEY, 'Please provide an artifact configuration');
        if (!empty($config[self::PREFS_KEY])) {
            $service = new ValidationService($config[self::PREFS_KEY], $errors, sprintf(
                'host-config.%s.%s', $config['configName'], self::PREFS_KEY));
            $service->hasKeys([
                'actions' => 'An artifact needs a list of actions',
            ]);
            foreach ($config[self::PREFS_KEY]['actions'] as $action) {
                $service = new ValidationService($action, $errors, sprintf(
                    'host-config.%s.%s.actions', $config['configName'], self::PREFS_KEY));
                $service->hasKeys([
                    'action' => 'Every action needs the kind of action to perform',
                    'arguments' => 'Missing arguments for an action'
                ]);
            }
        }
    }

    /**
     * Build the artifact into given directory.
     *
     * @param HostConfig $host_config
     * @param TaskContextInterface $context
     * @param ShellProviderInterface $shell
     * @param string $install_dir
     * @param array $stages
     * @throws MethodNotFoundException
     * @throws TaskNotFoundInMethodException
     * @throws MissingScriptCallbackImplementation
     */
    protected function buildArtifact(
        HostConfig $host_config,
        TaskContextInterface $context,
        ShellProviderInterface $shell,
        string $install_dir,
        array $stages
    )
    {
        $cloned_host_config = clone $host_config;
        $keys = ['rootFolder', 'composerRootFolder', 'gitRootFolder'];
        foreach ($keys as $key) {
            $cloned_host_config[$key] = $install_dir;
        }
        $shell->cd($cloned_host_config['tmpFolder']);
        $context->set('outerShell', $shell);
        $context->set('installDir', $install_dir);

        AppDefaultStages::executeStages(
            $context->getConfigurationService()->getMethodFactory(),
            $cloned_host_config,
            $stages,
            'appCreate',
            $context,
            'Building artifact'
        );

        $this->runDeployScript($cloned_host_config, $context);
    }

    protected function runStageSteps(HostConfig $host_config, TaskContextInterface $context, $implementations)
    {
        if (!$current_stage = $context->get('currentStage', false)) {
            throw new \InvalidArgumentException('Missing currentStage on context!');
        }

        $implementations = array_merge(
            [
                'runDeployScript',
                'runActions',
            ],
            $implementations
        );

        if (in_array($current_stage, $implementations)) {
            if (method_exists($this, $current_stage)) {
                $this->{$current_stage}($host_config, $context);
            } else {
                throw new \RuntimeException(sprintf('Missing or unimplemented stage `%s`', $current_stage));
            }
        }
    }

    /**
     * @param HostConfig $host_config
     * @param TaskContextInterface $context
     * @throws MethodNotFoundException
     * @throws MissingScriptCallbackImplementation
     */
    protected function runDeployScript(HostConfig $host_config, TaskContextInterface $context)
    {
        /** @var ScriptMethod $script_method */
        $script_method = $context->getConfigurationService()->getMethodFactory()->getMethod('script');
        $install_dir = $context->get('installDir');
        $context->set('variables', [
            'installFolder' => $install_dir,
        ]);
        $context->set('rootFolder', $install_dir);
        $script_method->runTaskSpecificScripts($host_config, 'deploy', $context);

        $context->setResult('skipResetStep', true);
    }
    
    
    public function runActions(HostConfig $host_config, TaskContextInterface $context) {

        $actions = $host_config[self::PREFS_KEY]['actions'];
        foreach ($actions as $action) {
            $fn_name = 'runAction'. ucfirst($action['action']);
            if (method_exists($this, $fn_name)) {
                $this->{$fn_name}($host_config, $context, $action);
            }
        }
    }
    /**
     * @param ShellProviderInterface $shell
     * @param $install_dir
     * @return array
     */
    private function getDirectoryContents(ShellProviderInterface $shell, $install_dir)
    {
        $contents = $shell->run('ls -1a ' . $install_dir, true);
        return array_filter($contents->getOutput(), function ($elem) {
            return !in_array($elem, ['.', '..']);
        });
    }

    /**
     * @param HostConfig $host_config
     * @param TaskContextInterface $context
     * @param array $action
     */
    protected function runActionCopy(HostConfig $host_config, TaskContextInterface $context, array $action)
    {
        /** @var ShellProviderInterface $shell */
        $shell = $context->get('outerShell', $host_config->shell());
        $install_dir = $context->get('installDir', false);
        $target_dir = $context->get('targetDir', false);

        $shell->pushWorkingDir($install_dir);

        if (count($action['arguments']) == 1 && $action['arguments'][0] = '*') {
            $files_to_copy = $this->getDirectoryContents($shell, $install_dir);
        } else {
            $files_to_copy = $action['arguments'];
        }

        $files_to_skip = $context->getConfigurationService()->getSetting('excludeFiles.gitSync', []);

        // Make sure that git-related files are skipped.
        $files_to_skip[] = ".git";

        foreach ($files_to_copy as $file) {
            if (!in_array($file, $files_to_skip)) {
                $shell->run(sprintf('cp -a %s %s', $file, $target_dir));
            }
        }

        $shell->popWorkingDir();
    }

    protected function runActionDelete(HostConfig $host_config, TaskContextInterface $context, array $action) {

        /** @var ShellProviderInterface $shell */
        $shell = $context->get('outerShell', $host_config->shell());
        $target_dir = $context->get('targetDir', false);

        $shell->pushWorkingDir($target_dir);

        $files_to_delete = $action['arguments'];
        foreach ($files_to_delete as $file) {
            $full_path = $target_dir . '/' . $file;
            $shell->run(sprintf('rm -rf %s', $full_path));
        }
        $shell->popWorkingDir();
    }
}
