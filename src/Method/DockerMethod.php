<?php

namespace Phabalicious\Method;

use Phabalicious\Configuration\ConfigurationService;
use Phabalicious\Configuration\DockerConfig;
use Phabalicious\Configuration\HostConfig;
use Phabalicious\Exception\EarlyTaskExitException;
use Phabalicious\Exception\MethodNotFoundException;
use Phabalicious\Exception\ValidationFailedException;
use Phabalicious\Validation\ValidationErrorBagInterface;
use Phabalicious\Validation\ValidationService;

class DockerMethod extends BaseMethod implements MethodInterface
{

    public function getName(): string
    {
        return 'docker';
    }

    public function supports(string $method_name): bool
    {
        return $method_name === 'docker';
    }

    public function getDefaultConfig(ConfigurationService $configuration_service, array $host_config): array
    {
        $config = parent::getDefaultConfig($configuration_service, $host_config); // TODO: Change the autogenerated stub
        $config['executables']['supervisorctl'] = 'supervisorctl';
        return $config;
    }

    public function validateConfig(array $config, ValidationErrorBagInterface $errors)
    {
        parent::validateConfig($config, $errors); // TODO: Change the autogenerated stub
        $validation = new ValidationService($config, $errors, 'host');
        $validation->isArray('docker', 'docker configuration needs to be an array');
        if (!$errors->hasErrors()) {
            $validation = new ValidationService($config['docker'], $errors, 'host.docker');
            $validation->hasKey('name', 'name of the docker-container to inspect');
            $validation->hasKey('configuration', 'name of the docker-configuration to use');
        }
    }

    /**
     * @param HostConfig $host_config
     * @param TaskContextInterface $context
     * @throws \Phabalicious\Exception\MethodNotFoundException
     * @throws \Phabalicious\Exception\MissingScriptCallbackImplementation
     */
    public function docker(HostConfig $host_config, TaskContextInterface $context)
    {
        $docker_config = $context->get('docker_config');
        $task = $context->get('docker_task');

        $tasks = $docker_config['tasks'];

        $this->runTaskImpl($host_config, $context, $task . 'Prepare', true);
        $this->runTaskImpl($host_config, $context, $task, false);
        $this->runTaskImpl($host_config, $context, $task . 'Finished', true);
    }

    /**
     * @param HostConfig $host_config
     * @param TaskContextInterface $context
     * @param $task
     * @throws \Phabalicious\Exception\MethodNotFoundException
     * @throws \Phabalicious\Exception\MissingScriptCallbackImplementation
     */
    private function runTaskImpl(HostConfig $host_config, TaskContextInterface $context, $task, $silent)
    {
        $this->logger->info('Running docker-task `' . $task . '` on `' . $host_config['configName']);

        if (method_exists($this, $task)) {
            $this->{$task}($host_config, $context);
            return;
        }

        /** @var DockerConfig $docker_config */
        $docker_config = $context->get('docker_config');
        $tasks = $docker_config['tasks'];

        if ($silent && empty($tasks[$task])) {
            return;
        }
        if (empty($tasks[$task])) {
            throw new MethodNotFoundException('Missing task `' . $task . '`');
        }

        $script = $tasks[$task];
        $environment = $docker_config->get('environment', []);
        $callbacks = [];

        /** @var ScriptMethod $method */
        $method = $context->getConfigurationService()->getMethodFactory()->getMethod('script');
        $context->set('scriptData', $script);
        $context->set('variables', [
            'dockerHost' => $docker_config->raw(),
        ]);
        $context->set('environment', $environment);
        $context->set('callbacks', $callbacks);
        $context->set('rootFolder', $docker_config['rootFolder']);
        $context->setShell($docker_config->shell());
        $docker_config->shell()->setOutput($context->getOutput());

        $method->runScript($host_config, $context);
    }

    public function getInternalTasks()
    {
        return [
            'waitForServices',
            'copySSHKeys',
            'startRemoteAccess'
        ];
    }

    /**
     * @param HostConfig $hostconfig
     * @param TaskContextInterface $context
     */
    private function waitForServices(HostConfig $hostconfig, TaskContextInterface $context)
    {
        if ($hostconfig['executables']['supervisorctl'] === false) {
            return;
        }
        $max_tries = 10;
        $tries = 0;
        $shell = $hostconfig->shell();

        while ($tries < $max_tries) {
            $result = $shell->run('#!supervisorctl status', true);

            $count_running = 0;
            $count_services = 0;
            foreach ($result->getOutput() as $line) {
                if (trim($line) != '') {
                    $count_services++;
                    if (strpos($line, 'RUNNING')) {
                        $count_running++;
                    }
                }
            }
            if ($result->getExitCode() !== 0) {
                throw new \RuntimeException('Error running supervisorctl, check the logs');
            }
            if ($result->getExitCode() == 0 && ($count_running == $count_services)) {
                $this->logger->notice('Services up and running!');
                return;
            }
            $tries++;
            $this->logger->notice('Waiting for 5 secs and try again ...');
            sleep(5);
        }
        $this->logger->error('Supervisord not coming up at all!');
    }

}