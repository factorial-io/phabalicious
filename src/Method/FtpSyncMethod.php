<?php

namespace Phabalicious\Method;

use Phabalicious\Configuration\ConfigurationService;
use Phabalicious\Configuration\HostConfig;
use Phabalicious\Exception\EarlyTaskExitException;
use Phabalicious\ShellProvider\ShellProviderInterface;
use Phabalicious\Utilities\AppDefaultStages;
use Phabalicious\Validation\ValidationErrorBagInterface;

class FtpSyncMethod extends BaseMethod implements MethodInterface
{

    const DEFAULT_FILE_SOURCES = [
        'public' => 'filesFolder',
        'private' => 'privateFilesFolder'
    ];

    public function getName(): string
    {
        return 'ftp-sync';
    }

    public function supports(string $method_name): bool
    {
        return $method_name === $this->getName();
    }

    public function getDefaultConfig(ConfigurationService $configuration_service, array $host_config): array
    {
        $return = parent::getDefaultConfig($configuration_service, $host_config);
        $return['tmpFolder'] = '/tmp';
        $return['executables'] = [
            'lftp' => 'lftp',
        ];

        $return['deployMethod'] = 'ftp-sync';

        return $return;
    }

    public function validateConfig(array $config, ValidationErrorBagInterface $errors)
    {
        parent::validateConfig($config, $errors); // TODO: Change the autogenerated stub
        if (in_array('drush', $config['needs'])) {
            $errors->addError('needs', 'The method `ftp-sync` is incompatible with the `drush`-method!');
        }
        if ($config['deployMethod'] !== 'ftp-sync') {
            $errors->addError('deployMethod', 'deployMethod must be `ftp-sync`!');
        }
    }

    /**
     * @param HostConfig $host_config
     * @param TaskContextInterface $context
     * @throws \Phabalicious\Exception\MethodNotFoundException
     * @throws \Phabalicious\Exception\TaskNotFoundInMethodException
     */
    public function deploy(HostConfig $host_config, TaskContextInterface $context)
    {
        if ($host_config['deployMethod'] !== 'ftp-sync') {
            return;
        }

        // First, create an app in a temporary-folder.
        $stages = $context->getConfigurationService()->getSetting(
            'appStages.createCode',
            AppDefaultStages::CREATE_CODE
        );
        $install_dir = $host_config['tmpFolder'] . '/' . $host_config['configName'] . '-' . time();
        $context->set('installDir', $install_dir);
        $cloned_host_config = clone $host_config;
        $keys = ['rootFolder', 'composerRootFolder', 'gitRootFolder'];
        foreach ($keys as $key) {
            $cloned_host_config[$key] = $install_dir;
        }
        $shell = $this->getShell($cloned_host_config, $context);
        $shell->cd($cloned_host_config['tmpFolder']);
        $context->set('outerShell', $shell);

        AppDefaultStages::executeStages(
            $context->getConfigurationService()->getMethodFactory(),
            $cloned_host_config,
            $stages,
            'appCreate',
            $context,
            'Creating code'
        );

        // Run deploy scripts
        /** @var ScriptMethod $script_method */
        $script_method = $context->getConfigurationService()->getMethodFactory()->getMethod('script');
        $script_method->runTaskSpecificScripts($host_config, 'reset', $context);

        $context->setResult('skipResetStep', true);

        // Now we can sync the files via FTP.
        // TODO

        // Cleanup.
        $shell->run(sprintf('rm -rf %s', $install_dir));

        // Do not run any next tasks.
        $context->setResult('runNextTasks', []);
    }


}
