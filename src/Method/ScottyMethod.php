<?php

namespace Phabalicious\Method;

use Phabalicious\Configuration\ConfigurationService;
use Phabalicious\Configuration\HostConfig;
use Phabalicious\Configuration\Storage\Node;
use Phabalicious\ShellProvider\RunOptions;
use Phabalicious\ShellProvider\ScottyShellProvider;
use Phabalicious\Utilities\Utilities;
use Phabalicious\Validation\ValidationErrorBagInterface;
use Phabalicious\Validation\ValidationService;

class ScottyMethod extends BaseMethod
{
    use ScaffoldHelperTrait;

    private array $authChecked = [];

    public function getName(): string
    {
        return 'scotty';
    }

    public function supports(string $method_name): bool
    {
        return $method_name === $this->getName();
    }

    public function getDefaultConfig(
        ConfigurationService $configuration_service,
        Node $host_config,
    ): Node {
        $parent = parent::getDefaultConfig(
            $configuration_service,
            $host_config
        );
        $global_settings = $configuration_service->getSetting('scotty', []);
        $config = [
            // Scotty shellProvider takes precedence over local
            'shellProvider' => ScottyShellProvider::PROVIDER_NAME,
        ];
        $config['executables']['scottyctl'] = 'scottyctl';

        // Merge global scotty settings with host-specific settings
        $config['scotty'] = Utilities::mergeData(
            $global_settings,
            $host_config->get('scotty', [])->asArray()
        );

        $config['scotty']['scaffold'] = $this->getScaffoldDefaultConfig(
            $host_config,
            $config,
            'scotty'
        );

        return $parent->merge(
            new Node($config, $this->getName().' method defaults')
        );
    }

    public function validateConfig(
        ConfigurationService $configuration_service,
        Node $config,
        ValidationErrorBagInterface $errors,
    ): void {
        parent::validateConfig($configuration_service, $config, $errors); // TODO: Change the autogenerated stub
        $this->validateScaffoldConfig($config, 'scotty', $errors);
        $validation_service = new ValidationService(
            $config->get('scotty'),
            $errors,
            'host.'.$config['configName'].'.scotty'
        );

        $validation_service->isArray(
            'scaffold',
            'The scaffold configuration needs to be an array'
        );
        $validation_service->hasKey(
            'server',
            'The scotty configuration needs a `server` key'
        );
        $validation_service->hasKey(
            'shellService',
            'The scotty configuration needs a `shellService` key'
        );
    }

    public function alterConfig(
        ConfigurationService $configuration_service,
        Node $data,
    ): void {
        parent::alterConfig($configuration_service, $data);

        $replacements = Utilities::expandVariables([
            'globals' => Utilities::getGlobalReplacements(
                $configuration_service
            ),
            'settings' => $configuration_service->getAllSettings(),
            'host' => $data->asArray(),
        ]);

        $data->expandReplacements($replacements, []);
    }

    public function preflightTask(string $task, HostConfig $config, TaskContextInterface $context): void
    {
        parent::preflightTask($task, $config, $context);

        // Only check if scotty method is actually being used
        if (!$config->isMethodSupported($this)) {
            return;
        }

        // Skip for non-operational tasks
        $skip_tasks = ['about', 'list', 'version', 'output', 'list:hosts'];
        if (in_array($task, $skip_tasks)) {
            return;
        }

        // Check once per config per execution
        $config_name = $config->getConfigName();
        if (!empty($this->authChecked[$config_name])) {
            return;
        }

        $this->authChecked[$config_name] = true;
        $this->verifyAuthentication($config, $context);
    }

    /**
     * Verify authentication by making a real API call.
     *
     * We use app:list instead of auth:status because auth:status
     * can incorrectly return success even when the token is expired.
     */
    protected function verifyAuthentication(HostConfig $config, TaskContextInterface $context): void
    {
        $scotty_data = $config->getData()->get('scotty');

        // Allow disabling auth check via configuration
        if (false === $scotty_data->get('verifyAuth', true)->getValue()) {
            $this->logger->debug('Scotty auth verification disabled via configuration');

            return;
        }

        // If access-token is explicitly provided, skip the check
        // (assume token-based auth via config)
        if (!empty($scotty_data->get('access-token')?->getValue())) {
            $this->logger->debug('Using configured access-token for scotty authentication');

            return;
        }

        // Perform a lightweight operation that requires valid authentication
        // Using app:list as it's fast and will fail immediately if auth is invalid
        $shell = $config->shell();
        $server = $scotty_data->get('server')->getValue();

        $this->logger->debug('Verifying scotty authentication...');

        $result = $shell->run(
            sprintf('#!scottyctl --server %s app:list', $server),
            RunOptions::CAPTURE_AND_HIDE_OUTPUT,
            false
        );

        if ($result->failed()) {
            $context->io()->error([
                'Failed to authenticate with scotty server.',
                '',
                'Your authentication token may be expired or invalid.',
                sprintf('Please login again: scottyctl --server %s auth:login', $server),
            ]);

            throw new \RuntimeException(sprintf('Scotty authentication failed. Run: scottyctl --server %s auth:login', $server));
        }

        $this->logger->info('Scotty authentication verified successfully');
    }

    public function scaffoldApp(
        HostConfig $host_config,
        TaskContext $context,
    ): string {
        $project_folder = $context->get(
            'installDir',
            Utilities::getTempFolder($host_config, 'scotty')
        );
        $shell = $host_config->shell();
        $this->runScaffolder(
            $host_config,
            $context,
            $shell,
            $project_folder,
            'scotty'
        );

        return $project_folder;
    }

    protected function destroyApp(
        HostConfig $host_config,
        TaskContext $context,
    ): void {
        $options = new ScottyCtlOptions($host_config, $context);
        $result = $options->runInShell($host_config->shell(), 'app:destroy');
        if ($result->failed()) {
            $result->throwException('Failed to run scottyctl destroy');
        }
    }

    protected function createApp(
        HostConfig $host_config,
        TaskContext $context,
    ): void {
        $app_folder = $this->scaffoldApp($host_config, $context);
        $options = new ScottyCtlCreateOptions($host_config, $context);
        $result = $options->runInShell($host_config->shell(), 'app:create', [
            'app_folder' => $app_folder,
        ]);
        if ($result->failed()) {
            $result->throwException('Failed to run scottyctl create');
        }
    }

    public function deploy(HostConfig $host_config, TaskContext $context): void
    {
        $this->createApp($host_config, $context);
    }

    public function appCheckExisting(
        HostConfig $host_config,
        TaskContext $context,
    ): bool {
        $options = new ScottyCtlOptions($host_config, $context);
        $result = $options
            ->runInShell($host_config->shell(), 'app:info', [], RunOptions::CAPTURE_AND_HIDE_OUTPUT)
            ->succeeded();
        $context->setResult('appExists', $result);
        $context->setResult('installName', $options->getRestEndpoint());

        return $result;
    }

    public function appCreate(
        HostConfig $host_config,
        TaskContext $context,
    ): void {
        $stage = $context->get('currentStage');
        if (!$stage) {
            throw new \InvalidArgumentException('Missing current stage');
        }
        if ('installCode' === $stage) {
            $this->createApp($host_config, $context);
        }
    }

    public function appDestroy(
        HostConfig $host_config,
        TaskContext $context,
    ): void {
        $stage = $context->get('currentStage');
        if (!$stage) {
            throw new \InvalidArgumentException('Missing current stage');
        }
        if ('deleteCode' === $stage) {
            $this->destroyApp($host_config, $context);
        }
    }
}
